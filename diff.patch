diff --git a/sorted_face/Line.js b/sorted_face/Line.js
index 39ee8a4..feaced5 100644
--- a/sorted_face/Line.js
+++ b/sorted_face/Line.js
@@ -6,13 +6,14 @@ export class Line {
         this.y2 = y2;
         this.weight = weight;
         this.color = col;
-        this.direction = direction
+        this.direction = direction;
         this.heightLevel = this.computeHeight(); // height of line on x=0
+        this.length = Math.pow(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2), 0.5);
     }
 
-    computeHeight(){
+    computeHeight() {
         const reverseDirectionAmount = this.x1 / this.direction.x;
-        return this.y1 - (reverseDirectionAmount * this.direction.y); 
+        return this.y1 - (reverseDirectionAmount * this.direction.y);
     }
 
     draw(pg) {
diff --git a/sorted_face/Solution.js b/sorted_face/Solution.js
index a7280d6..ab56f45 100644
--- a/sorted_face/Solution.js
+++ b/sorted_face/Solution.js
@@ -4,36 +4,55 @@ import { Line } from "./Line.js";
 
 
 export class Solution {
-    constructor(lines, pixelsToFollow, canvas_height, canvas_width) {
+    constructor(lines, canvas_height, canvas_width) {
         this.lines = lines;
         this.lines.sort((l1, l2) => l1.heightLevel < l2.heightLevel);
         this.canvas_width = canvas_width;
         this.canvas_height = canvas_height;
         this.distance = undefined;
-        this.pixelsToFollow = pixelsToFollow;
     }
 
-    computeDistance(pg) {
-        const imgPixels = getAllPixels(this.canvas_height, this.canvas_width, pg);
+    setDistance(dist) {
+        this.distance = dist;
+    }
+
+    clone() {
+        const sol = new Solution(this.lines, this.canvas_height, this.canvas_width);
+        sol.setDistance(this.distance);
+        return sol;
+    }
+
+    clear() {
+        this.lines = null
+        this.canvas_width = null
+        this.canvas_height = null
+        this.distance = null
+    }
+
+    computeDistance(pixelsToFollow, renderer) {
+        const imgPixels = getAllPixels(this.canvas_height, this.canvas_width, renderer);
         let dist = 0;
         for (var i = 0; i < this.canvas_height; i++) {
             for (var j = 0; j < this.canvas_width; j++) {
-                dist += Math.abs(imgPixels[i][j][0] - this.pixelsToFollow[i][j][0]) ** 2;
+                dist += Math.abs(imgPixels[i][j][0] - pixelsToFollow[i][j][0]) ** 2;
             }
         }
-        this.distance = dist;
-        return dist;
+        this.distance = dist / 1e6;
+        return this.distance;
     }
 
-    draw() {
-        let pg = createGraphics(this.canvas_width, this.canvas_height);
-        pg.background(0);
+    draw(pixelsToFollow) {
+        let renderer = createGraphics(this.canvas_width, this.canvas_height);
+
+        renderer.background(0);
         this.lines.forEach(line => {
-            line.draw(pg);
+            line.draw(renderer);
         });
-        image(pg, 0, 0, this.canvas_width, this.canvas_height);
-        pg.updatePixels();
-        this.computeDistance(pg);
+        image(renderer, 0, 0, this.canvas_width, this.canvas_height);
+        renderer.updatePixels();
+        this.computeDistance(pixelsToFollow, renderer);
+        renderer.pInst = null;
+        renderer = null;
     }
 
     drawMain() {
@@ -46,45 +65,56 @@ export class Solution {
     mutate(rate, strength) {
         if (rate < Math.random()) return;
         this.lines = this.lines.map(line => {
-            if (strength > Math.random()){
+            if (strength < Math.random()) return line;
+
+            const choice = Math.random();
+            if (choice < 0.1) { // delete and recreate a random line
                 let shade = randInt(10, 255);
                 let x1 = randInt(0, this.canvas_width);
                 let y1 = randInt(0, this.canvas_height);
                 let point = new Element2D(x1, y1);
                 let point2 = point.translate(line.direction, randInt(this.canvas_height / 10, this.canvas_height / 2));
-                let x2 = point2.x;
-                let y2 = point2.y;
-                return new Line(x1, y1, x2, y2, 1, shade, line.direction)
-            } else return line;
+                return new Line(x1, y1, point2.x, point2.y, 1, shade, line.direction)
+            }
+            else if (choice < 0.55) { // modify a random line along its axis
+                let shade = Math.min(Math.max(line.shade + randInt(-50, 50), 10), 255) // modify shade by something in [-50, 50]
+                let point = new Element2D(line.x1, line.y1);
+                let point2 = point.translate(line.direction, line.length + randInt(-Math.min(line.length / 4, 50), 50));
+                return new Line(line.x1, line.y1, point2.x, point2.y, 1, shade, line.direction)
+            } else {
+                let shade = Math.min(Math.max(line.shade + randInt(-50, 50), 10), 255) // modify shade by something in [-50, 50]
+                let point2 = new Element2D(line.x2, line.y2);
+                let point = point2.translate(line.direction, - (line.length + randInt(-Math.min(line.length / 4, 50), 50)));
+                return new Line(point.x1, point.y1, line.x2, line.y2, 1, shade, line.direction)
+            }
         })
     }
 
     clone() {
-        return new Solution(this.lines, this.pixelsToFollow, this.canvas_height, this.canvas_width)
+        return new Solution(this.lines, this.canvas_height, this.canvas_width)
     }
 
     makeChild(otherSolution) {
-        
         // two choices for mask
         const choice = Math.random();
         let childLines;
 
-        // 1 : sort all lines and take half of them
-        if(choice < 0.3){
+        // 1 : sort all lines and take half of them alternatively (not great ?)
+        if (choice < 0.3) {
             childLines = this.lines
                 .concat(otherSolution.lines)
                 .sort((l1, l2) => l1.heightLevel < l2.heightLevel)
-                .filter((_, i) => i%2 == 0);
+                .filter((_, i) => i % 2 == 0);
         }
 
-        // 2 : upper side and lower side
+        // 2 : upper side and lower side of each parent
         else {
             const l = this.lines.length;
-            childLines = this.lines.slice(0, l/2 + 1).concat(otherSolution.lines.slice(l/2 + 1, l));
+            childLines = this.lines.slice(0, l / 2 + 1).concat(otherSolution.lines.slice(l / 2 + 1, l));
         }
 
         // build and return child solution
-        return new Solution(childLines, this.pixelsToFollow, this.canvas_height, this.canvas_width)
+        return new Solution(childLines, this.canvas_height, this.canvas_width)
     }
 }
 
diff --git a/sorted_face/getAllPixels.js b/sorted_face/getAllPixels.js
index 6a662ac..445f828 100644
--- a/sorted_face/getAllPixels.js
+++ b/sorted_face/getAllPixels.js
@@ -1,7 +1,7 @@
-export function getAllPixels(canvas_height, canvas_width, pg) {
+export function getAllPixels(canvas_height, canvas_width, renderer) {
     // const flatPixels = get(0, 0, canvas_height, canvas_width).pixels;
-    pg.loadPixels();
-    const flatPixels = pg.pixels;
+    renderer.loadPixels();
+    const flatPixels = renderer.pixels;
     let imgPixels = new Array(canvas_height);
     for (var i = 0; i < canvas_height; i++) {
         imgPixels[i] = new Array();
diff --git a/sorted_face/sketch.js b/sorted_face/sketch.js
index 6459de3..20b1b0d 100644
--- a/sorted_face/sketch.js
+++ b/sorted_face/sketch.js
@@ -69,8 +69,8 @@ function constructRandomSolution(direction, pixelsToFollow, linesAmount) {
   const weight = 1;
   for (var i = 0; i < linesAmount; i++) {
     let shade = randInt(10, 255);
-    let x1 = randInt(canvas_height / 6, 5 * canvas_width / 6);
-    let y1 = randInt(canvas_height / 6, 5 * canvas_width / 6);
+    let x1 = randInt(0, canvas_width);
+    let y1 = randInt(0, canvas_height);
     let point = new Element2D(x1, y1);
     let point2 = point.translate(direction, randInt(canvas_height / 10, canvas_height / 2));
     let x2 = point2.x;
@@ -79,7 +79,7 @@ function constructRandomSolution(direction, pixelsToFollow, linesAmount) {
       new Line(x1, y1, x2, y2, weight, shade, direction)
     )
   }
-  return new Solution(solutionLines, pixelsToFollow, canvas_height, canvas_width);
+  return new Solution(solutionLines, canvas_height, canvas_width);
 }
 
 
@@ -87,12 +87,12 @@ function constructRandomSolution(direction, pixelsToFollow, linesAmount) {
 function pixelGlitch(directionVector, pixelsToFollow) {
   // draw a bunch of random lines along the same direction vector
   // then use a genetic algorithm to make these lines as close as possible to the pixelsToFollow matrix
-  const maxGeneration = 10; // amount of generation iterations
-  const populationSize = 200; // amount of item per generation
-  const bestSolutionsToKeepInEachGenerationAmount = 30;
+  const maxGeneration = 100; // amount of generation iterations
+  const populationSize = 50; // amount of item per generation
+  const bestSolutionsToKeepInEachGenerationAmount = 40;
   const randomSolutionsToKeepInEachGenerationAmount = 5;
-  const mutationRate = 0.15;
-  const mutationStrengthFactor = 0.02;
+  const mutationRate = 0.1;
+  const mutationStrengthFactor = 0.04;
   const linesPerSolutionAmount = 500;
   const firstGenerationSolutions = []
   for (var i = 0; i < populationSize; i++) {
@@ -105,48 +105,51 @@ function pixelGlitch(directionVector, pixelsToFollow) {
     )
   };
   firstGenerationSolutions.forEach(x => {
-    x.draw();
+    x.draw(pixelsToFollow);
   });
-  
+
   // breeding
   let currentGenerationSolutions = firstGenerationSolutions
   let currentGeneration = 0;
   let newGenerationSolutions = [];
   let curBest = 0;
-  while(currentGeneration < maxGeneration){
+  while (currentGeneration < maxGeneration) {
     currentGenerationSolutions = currentGenerationSolutions.sort((x, y) => x.distance < y.distance ? -1 : 1);
-    console.log(`Best of generation ${currentGeneration}: ${currentGenerationSolutions[0].distance / 1e6}`);
+    console.log(`Best of generation ${currentGeneration}: ${(currentGenerationSolutions[0].distance).toFixed(2)}`);
     curBest = currentGenerationSolutions[0].distance;
     currentGeneration += 1;
     newGenerationSolutions = [];
-    for(var i = 0; i < bestSolutionsToKeepInEachGenerationAmount; i++){
+    for (var i = 0; i < bestSolutionsToKeepInEachGenerationAmount; i++) {
       newGenerationSolutions.push(currentGenerationSolutions[i]);
     }
-    for(var i = 0; i < randomSolutionsToKeepInEachGenerationAmount; i++){
+    for (var i = 0; i < randomSolutionsToKeepInEachGenerationAmount; i++) {
       const index = randInt(bestSolutionsToKeepInEachGenerationAmount, populationSize - 1)
       newGenerationSolutions.push(currentGenerationSolutions[index]);
     }
     // make children between some of the best solutions of the current generation
-    while(newGenerationSolutions.length < populationSize){
+    while (newGenerationSolutions.length < populationSize) {
       const index1 = randInt(0, bestSolutionsToKeepInEachGenerationAmount + randomSolutionsToKeepInEachGenerationAmount - 1)
       const index2 = randInt(0, bestSolutionsToKeepInEachGenerationAmount + randomSolutionsToKeepInEachGenerationAmount - 1)
       const newSol = newGenerationSolutions[index1].makeChild(newGenerationSolutions[index2])
       newSol.mutate(mutationRate, mutationStrengthFactor);
       newGenerationSolutions.push(newSol.clone())
-      newGenerationSolutions.at(-1).draw();
+      newGenerationSolutions.at(-1).draw(pixelsToFollow);
     }
-    newGenerationSolutions = newGenerationSolutions.sort((x, y) => x.distance < y.distance ? -1 : 1);
+    // newGenerationSolutions = newGenerationSolutions.sort((x, y) => x.distance < y.distance ? -1 : 1);
     // console.log(curBest, newGenerationSolutions[0].distance)
-    currentGenerationSolutions = newGenerationSolutions;
+    // currentGenerationSolutions = newGenerationSolutions.map(x => x.clone());
+    currentGenerationSolutions = newGenerationSolutions.map(x => Object.assign(Object.create(Solution), x));
+    console.log(currentGenerationSolutions[0].distance)
+    newGenerationSolutions.map(x => x.clear())
   }
   currentGenerationSolutions = currentGenerationSolutions.sort((x, y) => x.distance < y.distance ? -1 : 1);
-  console.log(`Best of generation ${maxGeneration}: ${currentGenerationSolutions[0].distance / 1e6}`);
+  console.log(`Best of generation ${maxGeneration}: ${(currentGenerationSolutions[0].distance).toFixed(2)}`);
 }
 
 
 function setup() {
   createCanvas(canvas_width, canvas_height);
-  image(img, 0, 0);
+  image(img, 0, 0, canvas_width, canvas_height);
   colorMode(RGB);
   seed_random_modules()
 
@@ -159,7 +162,7 @@ function setup() {
 function draw() {
   // put drawing code here
   const blackenedPixels = blacken();
-  pixelGlitch(new Element2D(1, 1), blackenedPixels);
+  pixelGlitch(new Element2D(1, 1), JSON.parse(JSON.stringify(blackenedPixels)));
 }
 
 window.draw = draw;
